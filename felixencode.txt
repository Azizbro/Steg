

//start encode
    bdat = check_bitmap(fbmp);

    for (i=0;i<bdat.headersize;i++)
    { /* Copy header verbatim */
	   ch = fgetc(fbmp);
	   fputc(ch, ofp);
	}

    /* This buffer will store bytes from the input file, which lets us access each byte easily */
     buffer = (unsigned char *)malloc(bdat.numpixelbytes * sizeof(unsigned char));

    //store bitmap in array
    fread(buffer, 1, bdat.numpixelbytes, fbmp);

	//check size of data
	fseek(dfp, 0L, SEEK_END);
	datafilesize = ftell(dfp);
	rewind(dfp);

	loop = ( (8*datafilesize)/(bdat.numpixelbytes -32) )+1;//
	if (loop>8)
	{
		printf("Error: Bitmap too small to store data file.\n");
		return(0);
	}
	/* Calculating the corruption  */
	float corruption = 100 * datafilesize / bdat.numpixelbytes; //.check float or double
	printf("Steganographic process has created %.1f%% image corruption.\n", corruption);
	fflush(stdout);

	/* Modifying the bits to store the data file */
	int bitsmodpbyte = ((8 * datafilesize + bdat.numpixelbytes - 1) / bdat.numpixelbytes);
	printf("There was a maximum of %d bits modified per byte.\n", bitsmodpbyte);
	fflush(stdout);

	bufposition=0;	bufbitnumber =0;
	EncodeDataSizeByte(datafilesize>>24);  //encode 4 bytes data size
	EncodeDataSizeByte(datafilesize>>16); //encodes next 4 ...
	EncodeDataSizeByte(datafilesize>>8);
	EncodeDataSizeByte(datafilesize);

	while ( (t=fgetc(dfp)) != EOF )
	{
		for(i=7;i>-1;i--)
		{
			Encode1bit(bufbitnumber, t&bitmask[i]);
	    	IncBufPos();

		}
	}

	fwrite(buffer, 1, bdat.numpixelbytes, ofp);	//write buffer to output file









  bdat = check_bitmap(fbmp);

  for (i=0;i<bdat.headersize;i++)
  { /* Copy header verbatim */
     c = fgetc(fbmp);
   fputc(c, fout);
  }

  /* This buffer will store bytes from the input file, which lets us access each byte easily */
  buffer = (unsigned char *)malloc(bdat.numpixelbytes * sizeof(unsigned char));

  //store bitmap in array
  fread(buffer, 1, bdat.numpixelbytes, fbmp);

  //check size of data
  fseek(fdata, 0L, SEEK_END);
  datafilesize = ftell(dfata);
  rewind(fdata);

  loop = ( (8*datafilesize)/(bdat.numpixelbytes -32) )+1;//
  if (loop>8)
  {
    printf("Error: Bitmap too small to store data file.\n");
    return(0);
  }

  // Calculating the corruption
  float corruption = 100 * datafilesize / bdat.numpixelbytes; //.check float or double
  printf("Steganographic process has created %.1f%% image corruption.\n", corruption);
  fflush(stdout);

  // Modifying the bits to store the data file
  int bitsmodpbyte = ((8 * datafilesize + bdat.numpixelbytes - 1) / bdat.numpixelbytes);
  printf("There was a maximum of %d bits modified per byte.\n", bitsmodpbyte);
  fflush(stdout);

  bufposition=0;	bufbitnumber =0;

  EncodeDataSizeByte(datafilesize>>24);  //encode 4 bytes data size
  EncodeDataSizeByte(datafilesize>>16); //encodes next 4 ...
  EncodeDataSizeByte(datafilesize>>8);
  EncodeDataSizeByte(datafilesize);

  int t =0;

  while ( (t=fgetc(dfp)) != EOF )
  {
    for(i=7;i>-1;i--)
    {
      Encode1bit(bufbitnumber, t&bitmask[i]);

      // as it loops through it masks the bitmask[]

      // increaseBusPos
        IncBufPos();

    }
  }

  fwrite(buffer, 1, bdat.numpixelbytes, ofp);	//write buffer to output file
